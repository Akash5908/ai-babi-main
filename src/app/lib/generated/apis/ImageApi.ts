/* tslint:disable */
/* eslint-disable */
/**
 * AI Babe Public API
 * Lorem ipsum
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  HTTPValidationError,
  ImageParameters,
  LoraNameFriendly,
  ModelName,
  PhotoStyle,
  PostImagenRequest,
  PostImagenResponse,
} from '../models/index';
import {
    HTTPValidationErrorFromJSON,
    HTTPValidationErrorToJSON,
    ImageParametersFromJSON,
    ImageParametersToJSON,
    LoraNameFriendlyFromJSON,
    LoraNameFriendlyToJSON,
    ModelNameFromJSON,
    ModelNameToJSON,
    PhotoStyleFromJSON,
    PhotoStyleToJSON,
    PostImagenRequestFromJSON,
    PostImagenRequestToJSON,
    PostImagenResponseFromJSON,
    PostImagenResponseToJSON,
} from '../models/index';

export interface ExtractPngInfoImagenPngInfoPostRequest {
    image: Blob;
}

export interface ImagesForExistingAvatarImagenExistingAvatarPostRequest {
    serverUrl: string;
    avatarName: string;
    prompt?: string;
    numberOfImages?: number;
    loras?: Array<LoraNameFriendly>;
    loraCombination?: Array<LoraNameFriendly>;
    customTags?: string | null;
    negativeTags?: string | null;
    photoStyle?: PhotoStyle;
    useAdetailer?: boolean;
    nSFW?: boolean;
}

export interface ImagesForNewAvatarImagenNewAvatarPostRequest {
    customTags: string;
    serverUrl: string;
    model?: ModelName;
    numberOfImages?: number;
    loras?: Array<LoraNameFriendly>;
    loraCombination?: Array<LoraNameFriendly>;
    negativeTags?: string | null;
    photoStyle?: PhotoStyle;
    useAdetailer?: boolean;
    nSFW?: boolean;
}

export interface ImagesForPrasarnickyImagenPrasarnickyPostRequest {
    customTags: string;
    serverUrl: string;
    avatarName: string;
    variableCustomTags?: string | null;
    negativeTags?: string | null;
    numberOfImages?: number;
    loras?: Array<LoraNameFriendly>;
    loraCombination?: Array<LoraNameFriendly>;
    photoStyle?: PhotoStyle;
    useAdetailer?: boolean;
}

export interface UserGenerateImageImagenGenerateChatbotIdPostRequest {
    chatbotId: string;
    postImagenRequest: PostImagenRequest;
}

/**
 * 
 */
export class ImageApi extends runtime.BaseAPI {

    /**
     * Extract Png Info
     */
    async extractPngInfoImagenPngInfoPostRaw(requestParameters: ExtractPngInfoImagenPngInfoPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImageParameters>> {
        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling extractPngInfoImagenPngInfoPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        const response = await this.request({
            path: `/imagen/png-info`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImageParametersFromJSON(jsonValue));
    }

    /**
     * Extract Png Info
     */
    async extractPngInfoImagenPngInfoPost(requestParameters: ExtractPngInfoImagenPngInfoPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImageParameters> {
        const response = await this.extractPngInfoImagenPngInfoPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get Loras
     */
    async getLorasImagenLorasGetRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<string | null>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/imagen/loras`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse<any>(response);
    }

    /**
     * Get Loras
     */
    async getLorasImagenLorasGet(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<string | null>> {
        const response = await this.getLorasImagenLorasGetRaw(initOverrides);
        return await response.value();
    }

    /**
     * Images For Existing Avatar
     */
    async imagesForExistingAvatarImagenExistingAvatarPostRaw(requestParameters: ImagesForExistingAvatarImagenExistingAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['serverUrl'] == null) {
            throw new runtime.RequiredError(
                'serverUrl',
                'Required parameter "serverUrl" was null or undefined when calling imagesForExistingAvatarImagenExistingAvatarPost().'
            );
        }

        if (requestParameters['avatarName'] == null) {
            throw new runtime.RequiredError(
                'avatarName',
                'Required parameter "avatarName" was null or undefined when calling imagesForExistingAvatarImagenExistingAvatarPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['serverUrl'] != null) {
            formParams.append('server_url', requestParameters['serverUrl'] as any);
        }

        if (requestParameters['avatarName'] != null) {
            formParams.append('avatar_name', requestParameters['avatarName'] as any);
        }

        if (requestParameters['numberOfImages'] != null) {
            formParams.append('number_of_images', requestParameters['numberOfImages'] as any);
        }

        if (requestParameters['loras'] != null) {
            formParams.append('loras', requestParameters['loras']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['loraCombination'] != null) {
            formParams.append('lora_combination', requestParameters['loraCombination']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['customTags'] != null) {
            formParams.append('custom_tags', requestParameters['customTags'] as any);
        }

        if (requestParameters['negativeTags'] != null) {
            formParams.append('negative_tags', requestParameters['negativeTags'] as any);
        }

        if (requestParameters['photoStyle'] != null) {
            formParams.append('photo_style', requestParameters['photoStyle'] as any);
        }

        if (requestParameters['useAdetailer'] != null) {
            formParams.append('use_adetailer', requestParameters['useAdetailer'] as any);
        }

        if (requestParameters['nSFW'] != null) {
            formParams.append('NSFW', requestParameters['nSFW'] as any);
        }

        const response = await this.request({
            path: `/imagen/existing-avatar`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Images For Existing Avatar
     */
    async imagesForExistingAvatarImagenExistingAvatarPost(requestParameters: ImagesForExistingAvatarImagenExistingAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.imagesForExistingAvatarImagenExistingAvatarPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Images For New Avatar
     */
    async imagesForNewAvatarImagenNewAvatarPostRaw(requestParameters: ImagesForNewAvatarImagenNewAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['customTags'] == null) {
            throw new runtime.RequiredError(
                'customTags',
                'Required parameter "customTags" was null or undefined when calling imagesForNewAvatarImagenNewAvatarPost().'
            );
        }

        if (requestParameters['serverUrl'] == null) {
            throw new runtime.RequiredError(
                'serverUrl',
                'Required parameter "serverUrl" was null or undefined when calling imagesForNewAvatarImagenNewAvatarPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['customTags'] != null) {
            formParams.append('custom_tags', requestParameters['customTags'] as any);
        }

        if (requestParameters['serverUrl'] != null) {
            formParams.append('server_url', requestParameters['serverUrl'] as any);
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['numberOfImages'] != null) {
            formParams.append('number_of_images', requestParameters['numberOfImages'] as any);
        }

        if (requestParameters['loras'] != null) {
            formParams.append('loras', requestParameters['loras']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['loraCombination'] != null) {
            formParams.append('lora_combination', requestParameters['loraCombination']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['negativeTags'] != null) {
            formParams.append('negative_tags', requestParameters['negativeTags'] as any);
        }

        if (requestParameters['photoStyle'] != null) {
            formParams.append('photo_style', requestParameters['photoStyle'] as any);
        }

        if (requestParameters['useAdetailer'] != null) {
            formParams.append('use_adetailer', requestParameters['useAdetailer'] as any);
        }

        if (requestParameters['nSFW'] != null) {
            formParams.append('NSFW', requestParameters['nSFW'] as any);
        }

        const response = await this.request({
            path: `/imagen/new-avatar`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Images For New Avatar
     */
    async imagesForNewAvatarImagenNewAvatarPost(requestParameters: ImagesForNewAvatarImagenNewAvatarPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.imagesForNewAvatarImagenNewAvatarPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Images For Prasarnicky
     */
    async imagesForPrasarnickyImagenPrasarnickyPostRaw(requestParameters: ImagesForPrasarnickyImagenPrasarnickyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<any>> {
        if (requestParameters['customTags'] == null) {
            throw new runtime.RequiredError(
                'customTags',
                'Required parameter "customTags" was null or undefined when calling imagesForPrasarnickyImagenPrasarnickyPost().'
            );
        }

        if (requestParameters['serverUrl'] == null) {
            throw new runtime.RequiredError(
                'serverUrl',
                'Required parameter "serverUrl" was null or undefined when calling imagesForPrasarnickyImagenPrasarnickyPost().'
            );
        }

        if (requestParameters['avatarName'] == null) {
            throw new runtime.RequiredError(
                'avatarName',
                'Required parameter "avatarName" was null or undefined when calling imagesForPrasarnickyImagenPrasarnickyPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        const consumes: runtime.Consume[] = [
            { contentType: 'application/x-www-form-urlencoded' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['customTags'] != null) {
            formParams.append('custom_tags', requestParameters['customTags'] as any);
        }

        if (requestParameters['serverUrl'] != null) {
            formParams.append('server_url', requestParameters['serverUrl'] as any);
        }

        if (requestParameters['avatarName'] != null) {
            formParams.append('avatar_name', requestParameters['avatarName'] as any);
        }

        if (requestParameters['variableCustomTags'] != null) {
            formParams.append('variable_custom_tags', requestParameters['variableCustomTags'] as any);
        }

        if (requestParameters['negativeTags'] != null) {
            formParams.append('negative_tags', requestParameters['negativeTags'] as any);
        }

        if (requestParameters['numberOfImages'] != null) {
            formParams.append('number_of_images', requestParameters['numberOfImages'] as any);
        }

        if (requestParameters['loras'] != null) {
            formParams.append('loras', requestParameters['loras']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['loraCombination'] != null) {
            formParams.append('lora_combination', requestParameters['loraCombination']!.join(runtime.COLLECTION_FORMATS["csv"]));
        }

        if (requestParameters['photoStyle'] != null) {
            formParams.append('photo_style', requestParameters['photoStyle'] as any);
        }

        if (requestParameters['useAdetailer'] != null) {
            formParams.append('use_adetailer', requestParameters['useAdetailer'] as any);
        }

        const response = await this.request({
            path: `/imagen/prasarnicky`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        if (this.isJsonMime(response.headers.get('content-type'))) {
            return new runtime.JSONApiResponse<any>(response);
        } else {
            return new runtime.TextApiResponse(response) as any;
        }
    }

    /**
     * Images For Prasarnicky
     */
    async imagesForPrasarnickyImagenPrasarnickyPost(requestParameters: ImagesForPrasarnickyImagenPrasarnickyPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<any> {
        const response = await this.imagesForPrasarnickyImagenPrasarnickyPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User Generate Image
     */
    async userGenerateImageImagenGenerateChatbotIdPostRaw(requestParameters: UserGenerateImageImagenGenerateChatbotIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PostImagenResponse>> {
        if (requestParameters['chatbotId'] == null) {
            throw new runtime.RequiredError(
                'chatbotId',
                'Required parameter "chatbotId" was null or undefined when calling userGenerateImageImagenGenerateChatbotIdPost().'
            );
        }

        if (requestParameters['postImagenRequest'] == null) {
            throw new runtime.RequiredError(
                'postImagenRequest',
                'Required parameter "postImagenRequest" was null or undefined when calling userGenerateImageImagenGenerateChatbotIdPost().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        const response = await this.request({
            path: `/imagen/generate/{chatbot_id}`.replace(`{${"chatbot_id"}}`, encodeURIComponent(String(requestParameters['chatbotId']))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PostImagenRequestToJSON(requestParameters['postImagenRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PostImagenResponseFromJSON(jsonValue));
    }

    /**
     * User Generate Image
     */
    async userGenerateImageImagenGenerateChatbotIdPost(requestParameters: UserGenerateImageImagenGenerateChatbotIdPostRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PostImagenResponse> {
        const response = await this.userGenerateImageImagenGenerateChatbotIdPostRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
